# -*- coding: utf-8 -*-
"""PAD_02_wprowadzenie_do_Pythona_cwiczenia_i_praca_domowa.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O4cRWk2FEjI0K0LEPpmwirx-jdeGFspi

## iterator
"""

'''
Zadanie 1
Zaimplementuj własny iterator o nazwie tetranacci, zwracający kolejne liczby ciągu Tetranacciego.
Funkcja __init__ powinna posiadać parametr o nazwie steps określający liczbę wyrazów ciągu,
po których funkcja __next__ rzuca wyjątek StopIteration.
Napisz program, w którym wykorzystasz swój iterator do wypisania na ekranie kolejnych wyrazów tego ciągu.
Niech liczbę wyrazów do wypisania podaje użytkownik.

'''

class Tetranacci:
    def __init__(self,steps):
        self.steps=steps
        self.counter=0
        self.values=[0,0,0,1]

    def __iter__(self):
        return self
    def __next__(self):
        if self.counter<self.steps:
            self.counter+=1
            if self.counter<=4:
                 return self.values[self.counter-1]
            else:
                next_value = sum(self.values)
                self.values = self.values[1:] + [next_value]
                return next_value
        else:
            raise StopIteration

steps=10
tet1 = Tetranacci(steps)
for value in tet1:
    print(value)



iterator1 = iter([1,2,3,4])
next(iterator1)

"""## generator"""

'''
Zadanie 2
Zaimplementuj własny generator o nazwie accumulate,
zwracający kolejne sumy elementów z podanego obiektu iterowalnego.
'''


def accumulate(iterable_object):
    total = 0
    for element in iterable_object:
        total += element
        yield total

my_gen =accumulate({1,2,3,4,5})
print(next(my_gen))
print(next(my_gen))
print(next(my_gen))

'''
Zadanie 3

Napisz własny dekorator o nazwie hello. Wynikiem jego działania powinno być:
• wypisanie na ekranie napisu hello
• wywołanie funkcji przekazanej jako argument.
'''

def hello(my_function):
    def wrapper(*args,**kwargs):
        print("Hello")
        return my_function(*args,**kwargs)
    return wrapper

@hello
def greet(name):
    print(f'Nice to meet you {name}')

greet("Natalia")

'''
Zadanie 4
Zaimplementuj własną funkcję o nazwie tetranacci, zwracający określony element ciągu Tetranacciego.
Funkcja powinna posiadać parametr o nazwie n określający numer wyrazu ciągu do obliczenia.
Obliczenia wykonuj rekurencyjnie.
'''


def tetranacci(n):
    if n == 1 or n == 2 or n == 3:
        return 0
    elif n == 4 :
        return 1
    else:
        return tetranacci(n-1) + tetranacci(n-2) + tetranacci(n-3) + tetranacci(n-4)
print(tetranacci(10))

"""## klasy"""

'''
Zadanie 5
Stwórz klasę Pojazd z atrybutami predkosc_max i przebieg
stwórz instancję klasy i wydrukuj jej atrybuty do konsoli
tworzac instancję możesz podać dowolne wielkości
'''
class Pojazd:
    def __init__(self,predkosc_max,przebieg):
        self.predkosc_max=predkosc_max
        self.przebieg=przebieg

pojazd1=Pojazd(250 , 50)
print(pojazd1.predkosc_max,pojazd1.przebieg)

'''
Zadanie 6
Stwórz klasę Autobus, która dziedziczy po Pojeździe utworzonym wcześniej,
ale do atrybutów Autobusu dodaj jeszcze nazwę modelu
stwórz instancję klasy i wydrukuj jej atrybuty
'''
class Autobus(Pojazd):
        def __init__(self,predkosc_max,przebieg,nazwa_modelu):
                super().__init__(predkosc_max,przebieg)
                self.nazwa_modelu=nazwa_modelu
autobus1 = Autobus(300,300,'model autobusu 1')
print(autobus1.predkosc_max,autobus1.nazwa_modelu,autobus1.przebieg)

'''
Zadanie 7
klasie Pojazd utwórz metodę liczba_miejsc, która będzie przyjmowała jako argument liczbę miejsc i wyświetlała komunikat:
"{TU WSTAWIMY NAZWE POJAZDU} pomieści {LICZBA MIEJSC} osób."
Klasa Autobus ma też dziedziczyć tę metodę, ale dodatkowo przyjmować wartość domyślną dla liczby miejsc = 50
Utwórz instancję klasy aby zaprezentować działanie
'''
class Pojazd:
    def __init__(self,predkosc_max,przebieg,nazwa):
        self.predkosc_max=predkosc_max
        self.przebieg=przebieg
        self.nazwa=nazwa
    def liczba_miejsc(self,liczba_miejsc):
          return f'{self.nazwa} pomiesci {liczba_miejsc}'

pojazd1=Pojazd(250 , 50,"nazwa pojazdu1")
print(pojazd1.predkosc_max,pojazd1.przebieg)

class Autobus(Pojazd):
        def liczba_miejsc(self, liczba_miejsc=50):
              return super().liczba_miejsc(liczba_miejsc)

autobus1 = Autobus(300,300,'model autobusu 1')
print(autobus1.liczba_miejsc())
print(autobus1.liczba_miejsc(100))

'''
Zadanie 8
Sprawdź czy obiekt autobus jest instancją klasy Pojazd
'''

print(isinstance(autobus1,Pojazd))
print(isinstance(pojazd1,Autobus))

"""## PRACA DOMOWA (15 pkt)"""

'''
Zadanie 1 (4 pkt)
Wykorzystując dekoratory, napisz cache dla funkcji tetranacci z poprzedniego zadania.
Ten dekorator powinien zapobiegać przed ponownym obliczaniem tych samych wartości.
'''
cache= {}
def saved_values(fun):
    def wrapper(n):
      if n not in cache:
        if n == 1 or n == 2 or n == 3:
          cache[n] = 0
        elif n == 4:
          cache[n] = 1
        else:
          cache[n] = fun(n)
        print(f'saved for : {n}')
      else:
        print("found in memory")
      return cache[n]
    return wrapper

@saved_values
def tetranacci(n):
   return tetranacci(n-1) + tetranacci(n-2) + tetranacci(n-3) + tetranacci(n-4)

print(tetranacci(10))
print(tetranacci(8))
print(tetranacci(12))

'''
Zadanie 2 (4 pkt)
Zaimplementuj własny generator o nazwie repeat, zwracający obiekt podany przez użytkownika dokładnie N razy.
Jeśli wartość parametru N nie została określona, generator powinien zwracać wartości w nieskończoność.

PRZYKŁAD
repeat(10, 3) → 10 10 10
repeat(10, 5) → 10 10 10 10 10
repeat(5) → 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5…
repeat(5, None) → 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5…
'''

def repeat(my_object,N = None):

    if N != None :
        while N != 0 :
            print(my_object)
            N -= 1

    elif N == None:
        while N == None:
            print(my_object)
repeat(10,3)

repeat(10)

repeat(10,None)

'''
Zadanie 3 (1 pkt)
W kodzie z zajęć w klasie Pojazd utwórz atrybut, który niezależnie od utworzonego obiektu będzie miał taką samą wartość.
każdy obiekt ma mieć kolor biały
'''



class Pojazd:
    def __init__(self,predkosc_max,przebieg,nazwa):
        self.predkosc_max=predkosc_max
        self.przebieg=przebieg
        self.nazwa=nazwa
        kolor= "biały"
    def liczba_miejsc(self,liczba_miejsc):
          return f'{self.nazwa} pomiesci {liczba_miejsc} osoby'

pojazd2 = Pojazd(200,40,"smigacz")
pojazd3 = Pojazd(400,100,"blyskawica")
print(f'pojazd 2 ma kolor: {pojazd2.kolor}, nazywa sie: {pojazd2.nazwa}.  {pojazd2.liczba_miejsc(4)}')
print(f'pojazd 3 ma kolor: {pojazd3.kolor}, nazywa sie: {pojazd3.nazwa}.  {pojazd3.liczba_miejsc(1)}')

'''
Zadanie 4 (2 pkt)
Wykorzystaj klasy Autobus i Pojazd.
Zdefiniuj metodę opłata, k†óra będzie miała wartość domyślną liczba_miejsc * 100
Jeżeli Pojazd jest instancją Autobusu, opłata ma zostać powiększona o 10% wartości opłaty początkowej.
Np. jeżeli autobus domyślnie ma 50 miejsc to opłata całkowita wyniesie 5500
'''

class Pojazd:
    def __init__(self,predkosc_max,przebieg,nazwa,liczba_miejsc):
        self.predkosc_max=predkosc_max
        self.przebieg=przebieg
        self.nazwa=nazwa
        self.liczba_miejsc = liczba_miejsc


    def oplata(self):
          wartosc_oplaty = self.liczba_miejsc * 100

          if isinstance(Pojazd,Autobus):
              wartosc_oplaty += wartosc_oplaty*0.1

          return wartosc_oplaty



class Autobus(Pojazd):
      def __init__(self,predkosc_max,przebieg,nazwa,liczba_miejsc):
          super().__init__(predkosc_max,przebieg,nazwa,liczba_miejsc)

      def oplata(self):
        return super().oplata()

pojazd1 = Pojazd(200,100,"pojazd1",4)
autobus1 = Autobus(300,100,"autobus",50)
print (f'autobus: {autobus1.oplata()} pojazd: {pojazd1.oplata()} ')

'''
Zadanie 5 (4 pkt)
Napisz klasę FunkcjaKwadratowa, która przechowuje funkcje typu $ax^2$+bx+c.
Klasa powinna zawierać trzy pola: a, b, c, które są przypisywane w konstruktorze.
Główną metodą powinna być rozwiaz(), która zwraca miejsca zerowe podanej funkcji.
Należy zwrócić uwagę na przypadki gdy a=0, b=0 lub c=0,
a także obmyślić sposób informowania o nieskończonej liczbie, jednym lub zerze rozwiązań.
'''

'''
początek kodu dla ułatwienia

'''


class CountingException(Exception):
  "Raised when no solution to the equation"
  pass



import math

class FunkcjaKwadratowa:
    def __init__(self, a, b, c):
        self.a=a
        self.b=b
        self.c=c
        self.message = f'a : {self.a} , b: {self.b} , c: {self.c}'

    def wypisz(self):
       print(self.message)


    def oblicz_wartosc(self, x):
        wartosc = self.a * math.pow(x,2) + self.b * x + self.c
        return wartosc



    def rozwiaz(self): # zwroc miejsca zerowe czyli x
      try:
        if self.a == 0 or self.b == 0 or self.c ==0 :
          raise ArithmeticError

        delta = math.pow(self.b,2) - 4 * self.a * self.c

        if delta > 0:
          x1 =( self.b * (-1) - math.sqrt(delta) )/ 2 * self.a
          x2 = ( self.b * (-1) + math.sqrt(delta) )/ 2 * self.a
          return f'dwa miejsca zerowe {x1} {x2} '


        elif delta == 0 :
          x0 =( self.b * (-1)) / 2 * self.a
          return f'jedno miejsce zerowe: {x0}'

        else:
          raise CountingException()

      except CountingException:
         return  "Raised CoutingError: No solution"

      except ArithmeticError:
          return "Raised ArithmeticError: The value for a, b or c is 0"




def main():
    f1 = FunkcjaKwadratowa(2, 3, 1)
    f1.wypisz()
    print(f1.oblicz_wartosc(0))
    print(f1.oblicz_wartosc(1))

    print(FunkcjaKwadratowa(0, 0, 0).rozwiaz())
    print(FunkcjaKwadratowa(0, 0, 1).rozwiaz())
    print(FunkcjaKwadratowa(0, 2, 3).rozwiaz())
    print(FunkcjaKwadratowa(1, 2, 3).rozwiaz())
    print(FunkcjaKwadratowa(1, -5, 6).rozwiaz())
    print(FunkcjaKwadratowa(1, 4, 4).rozwiaz())

if __name__ == "__main__":
  main()

